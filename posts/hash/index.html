<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Hash | Home</title>
<meta name="keywords" content="go, algorithm">
<meta name="description" content="一些有关 Hash 的知识">
<meta name="author" content="Cqqqq777">
<link rel="canonical" href="https://cqqqq777.github.io/posts/hash/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1b82bbed8b13f853704558d527b681efaea938ce91e6ae8903e8b19e73b1b0f8.css" integrity="sha256-G4K77YsT&#43;FNwRVjVJ7aB766pOM6R5q6JA&#43;ixnnOxsPg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://cqqqq777.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cqqqq777.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cqqqq777.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cqqqq777.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://cqqqq777.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Hash" />
<meta property="og:description" content="一些有关 Hash 的知识" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cqqqq777.github.io/posts/hash/" /><meta property="og:image" content="https://cqqqq777.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-09T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://cqqqq777.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="Hash"/>
<meta name="twitter:description" content="一些有关 Hash 的知识"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://cqqqq777.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Hash",
      "item": "https://cqqqq777.github.io/posts/hash/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hash",
  "name": "Hash",
  "description": "一些有关 Hash 的知识",
  "keywords": [
    "go", "algorithm"
  ],
  "articleBody": "哈希函数 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。\n输入定义上是无穷的但是实际使用通常会设置阈值，如 MD5 接受0-2^64-1的范围。 输出的长度是固定的 对于计算机的计算能力是不可逆的 一个输入对应一个输出（也存在 hash 碰撞的问题） 哈希函数产生的映射应当保持均匀，即不要使得映射结果堆积在小区间的某一块区域。（即保证离散型和均匀性） 相关题目 一个包含40亿条数据的文件，每个数据为无符号的32位整数，要求在 1G 内存以内完成找到出现次数前百最多的数据\n思路：将文件中的每条数据进行 hash 后再对 n 取模，40亿条数据的结果应该都是均匀分布在0 - （n-1）范围上的，将结果相同的数据放入同一文件，对每个文件分别进行词频统计，得出 n 个数，合并后再取出最多的数据即可\n下面提供了一种思路，但是内存占用应该是比较大的，因为开启了多个协程且使用管道进行通信，想要降低内存可以改为串行处理\ntype KV struct { Key string Value int } func Handle(path string, n int, hFunc HFunc) *KV { f, err := os.Open(path) if err != nil { log.Fatalln(err) } defer f.Close() channels := make(map[int]chan string) for i := 0; i \u003c n; i++ { num := i ch := make(chan string) go writeFile(fmt.Sprintf(\"%d\", num), ch) channels[num] = ch } scanner := bufio.NewScanner(f) for scanner.Scan() { num := hFunc(scanner.Text()) % n ch := channels[num] ch \u003c- scanner.Text() } for _, v := range channels { close(v) } resCh := make(chan *KV, n) for i := 0; i \u003c n; i++ { num := i go readFile(fmt.Sprintf(\"%d\", num), resCh) } results := make([]*KV, n) for i := 0; i \u003c n; i++ { v := \u003c-resCh results[i] = v } sort.Slice(results, func(i, j int) bool { return results[i].Value \u003e results[j].Value }) return results[0] } func writeFile(path string, ch \u003c-chan string) { f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE, 0755) if err != nil { return } defer f.Close() for v := range ch { fmt.Fprintln(f, v) } } func readFile(path string, result chan\u003c- *KV) { f, err := os.Open(path) if err != nil { return } scanner := bufio.NewScanner(f) res := make(map[string]int) for scanner.Scan() { res[scanner.Text()] += 1 } maxKey := \"\" max := 0 for k, v := range res { if v \u003e max { maxKey = k max = v } } result \u003c- \u0026KV{Key: maxKey, Value: max} } 哈希表 经典 hash map 设计是这样的：一开始创建 n 个存储桶，对每个放入的 key 做 hash 操作后对 n 取模得到 a，将此数据放入 a 桶中。因为 hash 函数的均匀性，当某一个桶的数据数量达到某一阈值时，可以看做其他桶的数量也逼近此阈值，触发扩容。举个扩容的例子：新建原来存储桶的倍数个存储桶，将原来存储的数据重新进行 hash，对 2*n 取模的运算后放入对应桶中。\n对 hash map 的读操作与写操作类似，对 key 进行 hash，取模的操作后找到对应桶，再根据 key 具体值找到对应的 value\n只需要保证每个桶的数据量维持在一个较小的阈值，每次对数据的操作都是较小的常数时间的，扩容代价可能较大，但是不同语言都有自己的优化机制，我们在对hash map 操作的时候时间复杂度都可以看做是 O(1) 的\n相关题目 设计 RandomPool 结构\n【题目】 设计一种结构，在该结构中有如下三个功能: insert(key): 将某个 key 加入到该结构，做到不重复加入 delete(key): 将原本在结构中的某个key移除 getRandom(): 等概率随机返回结构中的任何一个key。\n【要求】 Insert、delete和getRandom方法的时间复杂度都是O(1)\n思路：维护两张表，一张 key-value，一张 value-key。insert 函数每次将 insert 前的 hash map 中数据个数作为 value，数据本身作为 key对两张表都进行 insert 操作。getRandom 函数就随机生成一个 0 - len(map) 的数作为 value 在表中查询对应的 key 返回即可。delete 操作删除先将两张 map 中最后一条记录的 value 变为为要删除的 key 的 value，然后进行删除操作\ntype RandomPool struct { keyValue map[string]int valueKey map[int]string } func NewRandomPool() *RandomPool { return \u0026RandomPool{keyValue: make(map[string]int), valueKey: make(map[int]string)} } func (r *RandomPool) Insert(key string) { value := len(r.valueKey) r.keyValue[key] = value r.valueKey[value] = key } func (r *RandomPool) GetRandom() string { random := rand.Intn(len(r.valueKey)) return r.valueKey[random] } func (r *RandomPool) Delete(key string) { if _, ok := r.keyValue[key]; !ok { return } size := len(r.valueKey) index := r.keyValue[key] last := r.valueKey[size] r.valueKey[index] = r.valueKey[size] r.keyValue[last] = index delete(r.valueKey, size) delete(r.keyValue, key) } 布隆过滤器 布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n原理 布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。\n特性 一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在。 布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。 适用场景 如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题\n布隆过滤器的典型应用有：\n数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用 BloomFilter 来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。 业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。 缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。 WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务 Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。 SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。 实现 布隆过滤器的存储结构是 bitmap\n相关 API：\n新增：将元素经过 k 个 hash 函数计算后的得到 k 个值，将这些值在 bitmap 中对应的位设置为1 查询：将元素经过 k 个 hash 函数计算后的得到 k 个值，如果这些值在 bitmap 中对应位置全为1，则极大可能已经存在了，有一位为0则一定不存在 在实现具体 API 前我们要先确定 bitmap 的大小和 k 的值，实际上这两个值并不都是越大越好，在样本数量和 hash 函数个数确定的情况下，bitmap 的大小与 失误率 p 大致为一个反比例函数；在样本数量和 bitmap 大小确定的时候，hash 函数的个数和失误率的关系就像对勾函数的上支。这两个值的选择要看具体的使用场景。\n计算公式：计算结果均向上取整，n 为样本量，p 为预期失误率\nbitmap 大小：m = - (n*lnp)/(ln2)^2\nhash 函数个数：k = ln2 * m/n\np真 = (1 - e^-((n*k真)/m真))^k真\ntype HFunc func(str string) int type BloomFilter struct { bitmap []byte hashFunc []HFunc } func NewBloomFilter(m int, hashFunctions ...HFunc) *BloomFilter { return \u0026BloomFilter{ bitmap: make([]byte, m/8+1), hashFunc: hashFunctions, } } func (b *BloomFilter) Add(str string) { bits := b.hash(str) for _, v := range bits { b.setBit(v) } } func (b *BloomFilter) Query(str string) bool { bits := b.hash(str) for _, v := range bits { if b.getBit(v) == 0 { return false } } return true } func (b *BloomFilter) hash(str string) []int { result := make([]int, 0, len(b.hashFunc)) for _, v := range b.hashFunc { result = append(result, v(str)) } return result } func (b *BloomFilter) getBit(offset int) int { blockIndex := offset / 8 bitIndex := offset % 8 return b.bitmap[blockIndex] \u003e\u003e bitIndex \u0026 1 } func (b *BloomFilter) setBit(offset int) { blockIndex := offset / 8 bitIndex := offset % 8 b.bitmap[blockIndex] = (1 \u003c\u003c bitIndex) | b.bitmap[blockIndex] } 一致性哈希 现在我们需要搭建一个分布式的数据存储服务器。我们需要考虑两个问题：第一个问题本质是数据分区，第二个是数据复制。\n对于一般的 hash 算法，解决方案是这样的：选取数据的某部分进行 hash 运算，再与服务器数量取模得到对应的服务器。但是这样处理的话面临一个很大的问题就是当服务器数量改变时，数据的迁移与备份，成本极高\n对于这个的问题的解决我们可以使用一致性 hash 算法\n大概思想 一致性 hash 算法可以用于数据和服务器节点，并确保在添加或删除服务器节点时只移动一小部分数据。\n将 hash 值域想象一个顺时针递增的环，对不同服务器信息进行 hash 运算结果（token）后放在环上，然后再每次处理数据的时候也对数据进行 hash 运算后打到环上，请求环上顺时针最近的服务器，每一台服务器处理的数据范围为 （上一个token+1）- \u003e token\n如何实现找到顺时针最近的服务器：对服务器计算得出的 token 值进行一个排序，将数据处理后得到的 hash 值在服务器 hash 值排序结果里面做二分查找，找到大于等于数据 hash 值的最左位置就是数据应该访问的服务器\n在使用一致性 hash 算法的时候要想实现数据迁移的成本比一般 hash 算法低得多\n新增服务器：在顺时针方向的下一台服务器的其原数据处理范围内被划分出来的属于新增服务器数据处理范围迁移到新增服务器即可 移除服务器：将将要移除的服务器的所有数据迁移到顺时针方向的下一台服务器 但是一致性 hash 算法也有可能会导致数据和负载分布的不均匀，对于这个问题，使用虚拟节点技术解决\n虚拟节点 在上面的解决方案中，为每一台服务器分配单个 token，也就是给一个服务器节点分配一个相对较大的数据范围。这是一种静态范围划分，需要根据给定的节点数量计算出对应的数据范围。\n在这个方案中添加或者删除节点时，如果我们希望各个服务器节点能够保持数据平衡和负载均衡，需要做大量的数据移动的工作。主要存在以下问题：\n增加或删除节点：将导致重新计算数据范围，给集群带来巨大的管理开销； 热点数据问题：由于每个节点都被分配了一个很大的范围，如果数据分布不均匀，一些节点可能会成为热点节点。 虚拟节点的核心就是：将原本很大的数据范围划分为很多个较小的数据范围，然后将数据范围分发给不同的服务器，这些较小的数据范围被称为虚拟节点，对于每一台服务器，管理多个小的数据范围。\n引入了虚拟节点的概念后对数据备份也可以有更好的优化：假设每台机器的数据需要备份3份，将每个数据计算出 hash 值后找到协调节点，此节点备份后再由顺时针的两个后续节点备份，这样每台服务器都会被其他服务器协调备份数据\n优点 由于虚拟节点将哈希范围划分为更小的子范围，可以帮助集群上的物理节点更均匀地分配负载，因此在添加或删除节点时能更快的重新平衡； 当添加新的服务器节点时，它会从现有的节点转移一些虚拟节点过来，以维护集群的平衡； 同样，当一个节点需要重建时，许多节点都会参与重建过程，而不是从固定数量的副本中获取数据。使用虚拟节点在服务器性能存在差异化时更容易管理； 我们可以将大量的虚拟节点分配给功能强大的服务器，而将数量较少的虚拟节点分配给功能较弱的服务器； 由于虚拟节点帮助为每个物理节点分配很多较小的范围，这也降低了出现热点问题的可能性。 实现 挖个坑以后有空写\n",
  "wordCount" : "742",
  "inLanguage": "en",
  "datePublished": "2023-12-09T00:00:00Z",
  "dateModified": "2023-12-09T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Cqqqq777"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cqqqq777.github.io/posts/hash/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cqqqq777.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cqqqq777.github.io/" accesskey="h" title="Home (Alt + H)">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://cqqqq777.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://cqqqq777.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://cqqqq777.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/cqqqq777" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://juejin.cn/user/84011460075709" title="Juejin">
                    <span>Juejin</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://cqqqq777.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://cqqqq777.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Hash
    </h1>
    <div class="post-meta"><span title='2023-12-09 00:00:00 +0000 UTC'>December 9, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Cqqqq777&nbsp;|&nbsp;<a href="https://https://github.com/cqqqq777/content/posts/hash.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0" aria-label="哈希函数">哈希函数</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae" aria-label="相关题目">相关题目</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%93%88%e5%b8%8c%e8%a1%a8" aria-label="哈希表">哈希表</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae-1" aria-label="相关题目">相关题目</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="布隆过滤器">布隆过滤器</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e7%90%86" aria-label="原理">原理</a></li>
                <li>
                    <a href="#%e7%89%b9%e6%80%a7" aria-label="特性">特性</a></li>
                <li>
                    <a href="#%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="适用场景">适用场景</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c" aria-label="一致性哈希">一致性哈希</a><ul>
                        
                <li>
                    <a href="#%e5%a4%a7%e6%a6%82%e6%80%9d%e6%83%b3" aria-label="大概思想">大概思想</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e8%8a%82%e7%82%b9" aria-label="虚拟节点">虚拟节点</a><ul>
                        
                <li>
                    <a href="#%e4%bc%98%e7%82%b9" aria-label="优点">优点</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0-1" aria-label="实现">实现</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="哈希函数">哈希函数<a hidden class="anchor" aria-hidden="true" href="#哈希函数">#</a></h2>
<p><strong>散列函数</strong>（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>
<ol>
<li>输入定义上是无穷的但是实际使用通常会设置阈值，如 MD5 接受0-2^64-1的范围。</li>
<li>输出的长度是<strong>固定</strong>的</li>
<li>对于计算机的计算能力是<strong>不可逆</strong>的</li>
<li>一个输入对应一个输出（也存在 hash 碰撞的问题）</li>
<li>哈希函数产生的映射应当保持均匀，即<strong>不要使得映射结果堆积在小区间的某一块区域</strong>。（即保证离散型和均匀性）</li>
</ol>
<h3 id="相关题目">相关题目<a hidden class="anchor" aria-hidden="true" href="#相关题目">#</a></h3>
<p>一个包含40亿条数据的文件，每个数据为无符号的32位整数，要求在 1G 内存以内完成找到出现次数前百最多的数据</p>
<p>思路：将文件中的每条数据进行 hash 后再对 n 取模，40亿条数据的结果应该都是均匀分布在0 - （n-1）范围上的，将结果相同的数据放入同一文件，对每个文件分别进行词频统计，得出 n 个数，合并后再取出最多的数据即可</p>
<p>下面提供了一种思路，但是内存占用应该是比较大的，因为开启了多个协程且使用管道进行通信，想要降低内存可以改为串行处理</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">KV</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Key</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Value</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">hFunc</span> <span class="nx">HFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">KV</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="nx">channels</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">num</span> <span class="o">:=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">go</span> <span class="nf">writeFile</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">),</span> <span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nx">channels</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ch</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">num</span> <span class="o">:=</span> <span class="nf">hFunc</span><span class="p">(</span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span> <span class="o">%</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ch</span> <span class="o">:=</span> <span class="nx">channels</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">channels</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">close</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">resCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">KV</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">num</span> <span class="o">:=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">      <span class="k">go</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">),</span> <span class="nx">resCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">results</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">KV</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">resCh</span>
</span></span><span class="line"><span class="cl">      <span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Value</span> <span class="p">&gt;</span> <span class="nx">results</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">   <span class="p">})</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">writeFile</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">readFile</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">result</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="o">*</span><span class="nx">KV</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">scanner</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewScanner</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">scanner</span><span class="p">.</span><span class="nf">Scan</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">res</span><span class="p">[</span><span class="nx">scanner</span><span class="p">.</span><span class="nf">Text</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">maxKey</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="nx">max</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">res</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="nx">maxKey</span> <span class="p">=</span> <span class="nx">k</span>
</span></span><span class="line"><span class="cl">         <span class="nx">max</span> <span class="p">=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">result</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">KV</span><span class="p">{</span><span class="nx">Key</span><span class="p">:</span> <span class="nx">maxKey</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="nx">max</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="哈希表">哈希表<a hidden class="anchor" aria-hidden="true" href="#哈希表">#</a></h2>
<p>经典 hash map 设计是这样的：一开始创建 n 个存储桶，对每个放入的 key 做 hash 操作后对 n 取模得到 a，将此数据放入 a 桶中。因为 hash 函数的均匀性，当某一个桶的数据数量达到某一阈值时，可以看做其他桶的数量也逼近此阈值，触发扩容。举个扩容的例子：新建原来存储桶的倍数个存储桶，将原来存储的数据重新进行 hash，对 2*n 取模的运算后放入对应桶中。</p>
<p>对 hash map 的读操作与写操作类似，对 key 进行 hash，取模的操作后找到对应桶，再根据 key 具体值找到对应的 value</p>
<p>只需要保证每个桶的数据量维持在一个较小的阈值，每次对数据的操作都是较小的常数时间的，扩容代价可能较大，但是不同语言都有自己的优化机制，我们在对hash map 操作的时候时间复杂度都可以看做是 O(1) 的</p>
<h3 id="相关题目-1">相关题目<a hidden class="anchor" aria-hidden="true" href="#相关题目-1">#</a></h3>
<p>设计 RandomPool 结构</p>
<p>【题目】 设计一种结构，在该结构中有如下三个功能: insert(key): 将某个 key 加入到该结构，做到不重复加入 delete(key): 将原本在结构中的某个key移除 getRandom(): 等概率随机返回结构中的任何一个key。</p>
<p>【要求】 Insert、delete和getRandom方法的时间复杂度都是O(1)</p>
<p>思路：维护两张表，一张 key-value，一张 value-key。insert 函数每次将 insert 前的 hash map 中数据个数作为 value，数据本身作为 key对两张表都进行 insert 操作。getRandom 函数就随机生成一个 0 - len(map) 的数作为 value 在表中查询对应的 key 返回即可。delete 操作删除先将两张 map 中最后一条记录的 value 变为为要删除的 key 的 value，然后进行删除操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">RandomPool</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">keyValue</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">   <span class="nx">valueKey</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewRandomPool</span><span class="p">()</span> <span class="o">*</span><span class="nx">RandomPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">RandomPool</span><span class="p">{</span><span class="nx">keyValue</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">),</span> <span class="nx">valueKey</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RandomPool</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">value</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">r</span><span class="p">.</span><span class="nx">keyValue</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">   <span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="p">=</span> <span class="nx">key</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RandomPool</span><span class="p">)</span> <span class="nf">GetRandom</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">random</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">[</span><span class="nx">random</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RandomPool</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">keyValue</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">size</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">index</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">keyValue</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="nx">last</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">[</span><span class="nx">size</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">[</span><span class="nx">size</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">   <span class="nx">r</span><span class="p">.</span><span class="nx">keyValue</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">   <span class="nb">delete</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">valueKey</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nb">delete</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">keyValue</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="布隆过滤器">布隆过滤器<a hidden class="anchor" aria-hidden="true" href="#布隆过滤器">#</a></h2>
<p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>向量和一系列随机<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射函数</a>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<h3 id="原理">原理<a hidden class="anchor" aria-hidden="true" href="#原理">#</a></h3>
<p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数</a>将这个元素映射成一个位<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>中的 K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>
<h3 id="特性">特性<a hidden class="anchor" aria-hidden="true" href="#特性">#</a></h3>
<ul>
<li><strong>一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在</strong>。</li>
<li><strong>布隆过滤器可以添加元素，但是不能删除元素</strong>。因为删掉元素会导致误判率增加。</li>
</ul>
<h3 id="适用场景">适用场景<a hidden class="anchor" aria-hidden="true" href="#适用场景">#</a></h3>
<p>如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题</p>
<p>布隆过滤器的典型应用有：</p>
<ul>
<li>数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用 BloomFilter 来减少不存在的行或列的磁盘查找。避免代价高昂的<a href="https://www.zhihu.com/search?q=%E7%A3%81%E7%9B%98%E6%9F%A5%E6%89%BE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1229656645%7D">磁盘查找</a>会大大提高数据库查询操作的性能。</li>
<li>业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li>
<li>缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在<a href="https://www.zhihu.com/search?q=%E5%B8%83%E9%9A%86%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1229656645%7D">布隆器</a>中，则直接返回。</li>
<li>WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li>
<li>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。</li>
<li>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。</li>
</ul>
<h3 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h3>
<p>布隆过滤器的存储结构是 bitmap</p>
<p>相关 API：</p>
<ol>
<li>新增：将元素经过 k 个 hash 函数计算后的得到 k 个值，将这些值在 bitmap 中对应的位设置为1</li>
<li>查询：将元素经过 k 个 hash 函数计算后的得到 k 个值，如果这些值在 bitmap 中对应位置全为1，则极大可能已经存在了，有一位为0则一定不存在</li>
</ol>
<p>在实现具体 API 前我们要先确定 bitmap 的大小和 k 的值，实际上这两个值并不都是越大越好，在样本数量和 hash 函数个数确定的情况下，bitmap 的大小与 失误率 p 大致为一个反比例函数；在样本数量和 bitmap 大小确定的时候，hash 函数的个数和失误率的关系就像对勾函数的上支。这两个值的选择要看具体的使用场景。</p>
<p>计算公式：计算结果均向上取整，n 为样本量，p 为预期失误率</p>
<p>bitmap 大小：m = - (n*lnp)/(ln2)^2</p>
<p>hash 函数个数：k = ln2 * m/n</p>
<p>p真 = (1 - e^-((n*k真)/m真))^k真</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">BloomFilter</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">bitmap</span>   <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">   <span class="nx">hashFunc</span> <span class="p">[]</span><span class="nx">HFunc</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewBloomFilter</span><span class="p">(</span><span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">hashFunctions</span> <span class="o">...</span><span class="nx">HFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">BloomFilter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">BloomFilter</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">bitmap</span><span class="p">:</span>   <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">m</span><span class="o">/</span><span class="mi">8</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nx">hashFunc</span><span class="p">:</span> <span class="nx">hashFunctions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BloomFilter</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">bits</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bits</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">b</span><span class="p">.</span><span class="nf">setBit</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BloomFilter</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">bits</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bits</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">getBit</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BloomFilter</span><span class="p">)</span> <span class="nf">hash</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">hashFunc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">hashFunc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nf">v</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">result</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BloomFilter</span><span class="p">)</span> <span class="nf">getBit</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">blockIndex</span> <span class="o">:=</span> <span class="nx">offset</span> <span class="o">/</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">   <span class="nx">bitIndex</span> <span class="o">:=</span> <span class="nx">offset</span> <span class="o">%</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">bitmap</span><span class="p">[</span><span class="nx">blockIndex</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="nx">bitIndex</span> <span class="o">&amp;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">BloomFilter</span><span class="p">)</span> <span class="nf">setBit</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">blockIndex</span> <span class="o">:=</span> <span class="nx">offset</span> <span class="o">/</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">   <span class="nx">bitIndex</span> <span class="o">:=</span> <span class="nx">offset</span> <span class="o">%</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">   <span class="nx">b</span><span class="p">.</span><span class="nx">bitmap</span><span class="p">[</span><span class="nx">blockIndex</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bitIndex</span><span class="p">)</span> <span class="p">|</span> <span class="nx">b</span><span class="p">.</span><span class="nx">bitmap</span><span class="p">[</span><span class="nx">blockIndex</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="一致性哈希">一致性哈希<a hidden class="anchor" aria-hidden="true" href="#一致性哈希">#</a></h2>
<p>现在我们需要搭建一个分布式的数据存储服务器。我们需要考虑两个问题：第一个问题本质是<strong>数据分区</strong>，第二个是<strong>数据复制</strong>。</p>
<p>对于一般的 hash 算法，解决方案是这样的：选取数据的某部分进行 hash 运算，再与服务器数量取模得到对应的服务器。但是这样处理的话面临一个很大的问题就是当服务器数量改变时，数据的迁移与备份，成本极高</p>
<p>对于这个的问题的解决我们可以使用一致性 hash 算法</p>
<h3 id="大概思想">大概思想<a hidden class="anchor" aria-hidden="true" href="#大概思想">#</a></h3>
<p>一致性 hash 算法可以用于数据和服务器节点，并确保在添加或删除服务器节点时只移动一小部分数据。</p>
<p>将 hash 值域想象一个顺时针递增的环，对不同服务器信息进行 hash 运算结果（token）后放在环上，然后再每次处理数据的时候也对数据进行 hash 运算后打到环上，请求环上顺时针最近的服务器，每一台服务器处理的数据范围为 （上一个token+1）- &gt; token</p>
<p>如何实现找到顺时针最近的服务器：对服务器计算得出的 token 值进行一个排序，将数据处理后得到的 hash 值在服务器 hash 值排序结果里面做二分查找，找到大于等于数据 hash 值的最左位置就是数据应该访问的服务器</p>
<p>在使用一致性 hash 算法的时候要想实现数据迁移的成本比一般 hash 算法低得多</p>
<ul>
<li>新增服务器：在顺时针方向的下一台服务器的其原数据处理范围内被划分出来的属于新增服务器数据处理范围迁移到新增服务器即可</li>
<li>移除服务器：将将要移除的服务器的所有数据迁移到顺时针方向的下一台服务器</li>
</ul>
<p>但是一致性 hash 算法也有<strong>可能会导致数据和负载分布的不均匀</strong>，对于这个问题，使用<strong>虚拟节点</strong>技术解决</p>
<h3 id="虚拟节点">虚拟节点<a hidden class="anchor" aria-hidden="true" href="#虚拟节点">#</a></h3>
<p>在上面的解决方案中，为每一台服务器分配单个 token，也就是给一个服务器节点分配一个相对较大的数据范围。这是一种静态范围划分，需要根据给定的节点数量计算出对应的数据范围。</p>
<p>在这个方案中添加或者删除节点时，如果我们希望各个服务器节点能够保持数据平衡和负载均衡，需要做大量的数据移动的工作。主要存在以下问题：</p>
<ul>
<li>增加或删除节点：将导致重新计算数据范围，给集群带来巨大的管理开销；</li>
<li>热点数据问题：由于每个节点都被分配了一个很大的范围，如果数据分布不均匀，一些节点可能会成为热点节点。</li>
</ul>
<p>虚拟节点的核心就是：将原本很大的数据范围划分为很多个较小的数据范围，然后将数据范围分发给不同的服务器，这些较小的数据范围被称为虚拟节点，对于每一台服务器，管理多个小的数据范围。</p>
<p><img loading="lazy" src="https://dl-harmonyos.51cto.com/images/202210/07d03a555b6ee248673340297323beb8d7b1fb.png" alt="一致性hash算法，有点意思。。-开源基础软件社区"  />
</p>
<p>引入了虚拟节点的概念后对数据备份也可以有更好的优化：假设每台机器的数据需要备份3份，将每个数据计算出 hash 值后找到协调节点，此节点备份后再由顺时针的两个后续节点备份，这样每台服务器都会被其他服务器协调备份数据</p>
<h4 id="优点">优点<a hidden class="anchor" aria-hidden="true" href="#优点">#</a></h4>
<ul>
<li>由于虚拟节点将哈希范围划分为更小的子范围，可以帮助集群上的物理节点更均匀地分配负载，因此在添加或删除节点时能更快的重新平衡；</li>
<li>当添加新的服务器节点时，它会从现有的节点转移一些虚拟节点过来，以维护集群的平衡；</li>
<li>同样，当一个节点需要重建时，许多节点都会参与重建过程，而不是从固定数量的副本中获取数据。使用虚拟节点在服务器性能存在差异化时更容易管理；</li>
<li>我们可以将大量的虚拟节点分配给功能强大的服务器，而将数量较少的虚拟节点分配给功能较弱的服务器；</li>
<li>由于虚拟节点帮助为每个物理节点分配很多较小的范围，这也降低了出现热点问题的可能性。</li>
</ul>
<h3 id="实现-1">实现<a hidden class="anchor" aria-hidden="true" href="#实现-1">#</a></h3>
<p>挖个坑以后有空写</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://cqqqq777.github.io/tags/go/">go</a></li>
      <li><a href="https://cqqqq777.github.io/tags/algorithm/">algorithm</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>Copyright © 2023 Cqqqq777 Blog.</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
